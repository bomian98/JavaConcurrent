## 1 Executor 框架

Executor 框架的依赖关系图：
![](ScheduledThreadPoolExecutor.png)

### 1.1 Executor 接口

`Executor` 接口仅包含一个 `void execute(Runnable command);` 方法。

顶层接口 Executor 提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供 Runnable 对象，将任务的运行逻辑提交到执行器(Executor)中，由 Executor 框架完成线程的调配和任务的执行部分。

### 1.2 ExecutorService 接口

`ExecutorService` 接口对 `Executor` 接口进行了如下扩展，增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成 Future 的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。

![](ExecutorService_uml.png)

- `awaitTermination` 阻塞方法，等待线程池退出后才会结束自身。
- `invokeAll` 进行批量提交
- `isShutdown` 判断是否 shutdown
- `isTerminated` 如果所有任务在关闭后都已完成，则返回 true。除非首先调用了 shutdown 或 shutdownNow，否则 isTerminated 永远不会为真。
- `shutdown` 将线程池的状态设置为 SHUTWDOWN 状态，正在执行的任务会继续执行下去，没有被执行的则中断。此时，不能添加新任务，否则抛出 RejectedExecutionException 异常。
- `shutdownNow` 则是将线程池的状态设置为 STOP，正在执行的任务则被停止，没被执行任务的则返回。它试图终止线程的方法是通过调用 `Thread.interrupt()` 方法来实现的，但是这种方法的作用有限，如果线程中没有 sleep 、wait、Condition、定时锁等应用, interrupt() 方法是无法中断当前的线程的。所以，ShutdownNow() 并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。
- `submit` 提交不同类型的任务

### 1.3 AbstractExecutorService 抽象类

实现了 `ExecutorService` 接口，实现了 `invokeAll` 、 `invokeAny` 、 `submit` 方法。`ThreadPoolExecutor` 类直接继承了这些方法，没有重写方法。(后续再了解任务的执行过程的时候，直接看这里的源码)

![](AbstractExecutorService.png)

### 1.4 ThreadPoolExecutor 类

继承了 `AbstractExecutorService` 抽象类，线程池的主要实现类。

![](ThreadPoolExecutor.png)

### 1.5 ScheduledExecutorService 接口

周期性执行或延迟执行，后续再学习。

### 1.6 ScheduledThreadPoolExecutor 类

周期性执行或延迟执行，后续再学习。

## 2 ThreadPoolExecutor 类分析

### 2.1 构造函数

```java
public ThreadPoolExecutor(int corePoolSize,
						  int maximumPoolSize,
						  long keepAliveTime,
						  TimeUnit unit,
						  BlockingQueue<Runnable> workQueue,
						  ThreadFactory threadFactory,
						  RejectedExecutionHandler handler) {
	if (corePoolSize < 0 ||
		maximumPoolSize <= 0 ||
		maximumPoolSize < corePoolSize ||
		keepAliveTime < 0)
		throw new IllegalArgumentException();
	if (workQueue == null || threadFactory == null || handler == null)
		throw new NullPointerException();
	this.corePoolSize = corePoolSize;
	this.maximumPoolSize = maximumPoolSize;
	this.workQueue = workQueue;
	this.keepAliveTime = unit.toNanos(keepAliveTime);
	this.threadFactory = threadFactory;
	this.handler = handler;
}
```

- corePoolSize 线程池的核心线程数量，定义了最小可以同时运行的线程数量。
- maximumPoolSize 线程池的最大线程数，当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量变为最大线程数。
- keepAliveTime 当线程数大于 corePoolSize 时，空闲的线程能存活的时间，超过就销毁线程。
- unit 时间单位。
- workQueue 任务队列，用来储存等待执行任务的队列。
- threadFactory 线程工厂，用来创建线程，一般默认即可。
- handler 拒绝策略，当任务过多时，该如何处理新任务。

### 2.2 ThreadPoolExecutor 运行机制

线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。

任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。

线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。

![](https://p0.meituan.net/travelcube/77441586f6b312a54264e3fcf5eebe2663494.png)

### 2.3 线程池的状态/生命周期

ThreadPoolExecutor 类包含多个成员变量与相关函数，如下所示。
```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));  
private static final int COUNT_BITS = Integer.SIZE - 3;  
private static final int COUNT_MASK = (1 << COUNT_BITS) - 1;  
  
// runState is stored in the high-order bits  
private static final int RUNNING = -1 << COUNT_BITS;  
private static final int SHUTDOWN =  0 << COUNT_BITS;  
private static final int STOP =  1 << COUNT_BITS;  
private static final int TIDYING =  2 << COUNT_BITS;  
private static final int TERMINATED =  3 << COUNT_BITS;  
  
// Packing and unpacking ctl  
private static int runStateOf(int c)     { return c & ~COUNT_MASK; }  
private static int workerCountOf(int c)  { return c & COUNT_MASK; }  
private static int ctlOf(int rs, int wc) { return rs | wc; }

private static boolean runStateLessThan(int c, int s) { return c < s;}
private static boolean runStateAtLeast(int c, int s) { return c >= s;}
private static boolean isRunning(int c) { return c < SHUTDOWN;}
```

`ctl` 用来存储**运行状态**(runState)和**线程数量** (workerCount)。其中，低 29 位用于存储线程数量，高 3 位用来存储运行状态。官方注释表示，若线程数目称为问题，则可以将 AtomicInteger 更改为 AtomicLong，并且调整后面的移位/掩码就可以。

对于 `ctl` 变量，有三个相对应的方法。`runStateOf` 计算当前运行状态，`workerCountOf` 计算当前线程数量，`ctlOf` 根据状态和线程数生成 ctl。

ThreadPoolExecutor 有 5 种运行状态：
- `RUNNING` 能接受提交的任务，并且能够处理阻塞队列的任务。
- `SHUTDOWN` 关闭状态，不再接受新提交的任务，但可以继续处理阻塞队列中已保存的任务。
- `STOP` 不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。
- `TIDYING` 所有任务都已终止，workerCount 有效线程数为 0.
- `TERMINATED` 在 terminated 方法执行完后进入该状态。

这 5 种运行状态从上到下依次递增，叠加线程数量后，可以通过比较运算来判断处于的运行状态。

运行状态转换/生命周期如下：
![](https://p0.meituan.net/travelcube/582d1606d57ff99aa0e5f8fc59c7819329028.png)

### 2.4 任务执行机制
#### 2.4.1 任务分配

`Runnable` 或 `Callable` 对象通过 `submit` 方法传入时，会由 `AbstractExecutorService` 抽象类将输入转换为 `RunnableFuture<?>` 对象，然后调用 `ThreadPoolExecutor` 的 `execute(Runnable)` 方法执行。`Runnable` 对象也可以通过 `execute` 方法传入，则直接调用 `ThreadPoolExecutor` 的 `execute(Runnable)` 方法执行。

`AbstractExecutorService` 抽象类对于 `submit` 方法的实现。
```java
public Future<?> submit(Runnable task) {  
    if (task == null) throw new NullPointerException();  
	 RunnableFuture<Void> ftask = newTaskFor(task, null);  
	 execute(ftask);  
	 return ftask;  
}  
  
 public <T> Future<T> submit(Runnable task, T result) {  
    if (task == null) throw new NullPointerException();  
	 RunnableFuture<T> ftask = newTaskFor(task, result);  
	 execute(ftask);  
	 return ftask;  
}  
  
 public <T> Future<T> submit(Callable<T> task) {  
	 if (task == null) throw new NullPointerException();  
	 RunnableFuture<T> ftask = newTaskFor(task);  
	 execute(ftask);  
	 return ftask;  
}
```

`ThreadPoolExecutor` 类对 `execute` 方法的实现。
```java
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```

如果一个任务可以成功排队，那么我们仍然需要仔细检查我们是否应该添加一个线程（因为现有的线程自上次检查后就死了）或者任务在进入此方法后线程池关闭。因此，重新检查状态，如果有必要，如果停止排队，则回滚，或者如果没有，则启动一个新线程。

大致执行流程如下：
![](https://p0.meituan.net/travelcube/31bad766983e212431077ca8da92762050214.png)

#### 2.4.2 任务缓冲

`ThreadPoolExecutor` 使用阻塞队列来缓冲需要执行的任务，对应成员变量如下：
`private final BlockingQueue<Runnable> workQueue;`

在 `execute` 方法中，将 `Runnable` 对象添加进阻塞队列中，是唯一入口；在 `getTask` 方法中，从阻塞队列中取出一个 `Runnable` 对象，是唯一出口。

补充一个阻塞队列的各种实现类。
![](https://p0.meituan.net/travelcube/725a3db5114d95675f2098c12dc331c3316963.png)

#### 2.4.3 任务获取

```java
private Runnable getTask() {
		// BlockingQueue的poll方法是否已经超时
        boolean timedOut = false; 
        for (;;) {
            int c = ctl.get();
			// 如果线程池状态>=SHUTDOWN,并且BlockingQueue为null;
	        // 或者线程池状态>=STOP
	        // 以上两种情况都减少工作线程的数量, 返回的task为null
            if (runStateAtLeast(c, SHUTDOWN)
                && (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }
            // 获得当前工作线程个数
            int wc = workerCountOf(c);  
            // 当前线程是否需要被淘汰
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize; 
            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }
            try {
	            // BlockingQueue的poll方法超时会直接返回null
	            // BlockingQueue的take方法, 如果队列中没有元素, 当前线程会wait, 直到其他线程提交任务入队唤醒当前线程.
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
```

#### 2.4.4 任务拒绝

任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到 maximumPoolSize 时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。

拒绝策略是一个接口，其设计如下：

```Java
public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
```

用户可以通过实现这个接口去定制拒绝策略，也可以选择 JDK 提供的四种已有拒绝策略，其特点如下：

![](https://p0.meituan.net/travelcube/9ffb64cc4c64c0cb8d38dac01c89c905178456.png)

```java
public static class CallerRunsPolicy implements RejectedExecutionHandler {
	public CallerRunsPolicy() { }
	public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
		if (!e.isShutdown()) { r.run(); }
	}
}
public static class AbortPolicy implements RejectedExecutionHandler {
	public AbortPolicy() { }
	public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
		throw new RejectedExecutionException("Task " + r.toString() + " rejected from " + e.toString());
	}
}
public static class DiscardPolicy implements RejectedExecutionHandler {
	public DiscardPolicy() { }
	public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { }
}

public static class DiscardOldestPolicy implements RejectedExecutionHandler {
	public DiscardOldestPolicy() { }
	public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
		if (!e.isShutdown()) {
			e.getQueue().poll();
			e.execute(r);
		}
	}
}
```

### 2.5 线程执行机制




## 3 Executors 工厂


## 4 Reference

- [Java线程池实现原理及其在美团业务中的实践 - 美团技术团队](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)
- [线程池中shutdown()和shutdownNow()方法的区别 - aspirant - 博客园](https://www.cnblogs.com/aspirant/p/10265863.html)
- [Java8线程池ThreadPoolExecutor底层原理及其源码解析 - rhyme - 博客园](https://www.cnblogs.com/theRhyme/p/13056215.html)