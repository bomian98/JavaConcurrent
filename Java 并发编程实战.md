---
number headings: 1
---

## 第 2 章 - 线程安全性

> 要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的（Shared）和可变的（Mutable）状态的访问。

> “共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。

>线程安全性的实现：
>
>不在线程之间共享该状态变量。(ThreadLocal 或方法的局部变量)
>
>将状态变量修改为不可变的变量。
>
>在访问状态变量时使用同步。

>编写并发应用程序时，一种正确的编程方法就是：首先使代码正确运行，然后再提高代码的速度。
>即便如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能带来性能提升时，才进行优化。

确实，之前在做选排课系统时，我了解操作 Redis 是直接操作内存，相较于操作 MySQL 会更快一些。但是，我并没有实际的去测试使用 Redis 前后性能提升有多少。

>线程安全的程序是否完全由线程安全类构成？答案是否定的，完全由线程安全类构成的程序并不一定就是线程安全的，而在线程安全类中也可以包含非线程安全的类。

例如：判断在 ConcurrentHashMap 中是否存在某个 key，不存在，则插入数据。这就是不安全的指令，属于竞态条件的一种。

### 2.1 什么是线程安全性

> 当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

> 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

> 无状态对象一定是线程安全的。

> 大多数 Servlet 都是无状态的，从而极大地降低了在实现 Servlet 线程安全性时的复杂性。只有当 Servlet 在处理请求时需要保存一些信息，线程安全性才会成为一个问题。

### 2.2 原子性

>虽然递增操作++count 是一种紧凑的语法，使其看上去只是一个操作，但这个操作并非原子的，因而它并不会作为一个不可分割的操作来执行。实际上，它包含了三个独立的操作：读取 count 的值，将值加 1，然后将计算结果写入 count。这是一个“读取-修改-写入”的操作序列，并且其结果状态依赖于之前的状态。

自增操作不是一个原子操作！！

> 在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件（Race Condition）。

#### 2.2.1 竞态条件

> 最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作。

#### 2.2.2 延迟初始化中的竞态条件

>使用“先检查后执行”的一种常见情况就是延迟初始化。延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。

懒加载的单例模式，线程不安全。
可能存在两个线程都判空，并都创建了对象、赋值和返回，从而导致使用了地址不同的对象。

#### 2.2.3 复合操作

> 在 java.util.concurrent.atomic 包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。

AtomicInteger 的自增操作调用了下面的函数。
``` Java
@HotSpotIntrinsicCandidate
public final int getAndSetInt(Object o, long offset, int newValue) {
	int v;
	do {
		v = getIntVolatile(o, offset);
	} while (!weakCompareAndSetInt(o, offset, v, newValue));
	return v;
}
```

### 2.3 加锁机制

> 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

Redis 同理，如果某个操作需要更新两个数据，那么调用两次 Redis 的 API 是不行的。我当前使用的是借助 Lua 来操作

#### 2.3.1 内置锁

>Java 提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。（第 3 章将介绍加锁机制以及其他同步机制的另一个重要方面：可见性）
>
>同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。
>
>以关键字 synchronized 来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的 synchronized 方法以 Class 对象作为锁。

锁住方法：
1 - 普通方法，锁住的是当前执行该方法的实例对象
2 - 静态方法，锁住的是类对象。

#### 2.3.2 重入

> 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”

> 重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。
> 当计数值为 0 时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM 将记下锁的持有者，并且将获取计数值置为 1。
> 如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为 0 时，这个锁将被释放。

> 重入进一步提升了加锁行为的封装性，因此简化了面向对象并发代码的开发。在程序清单 2-7 (P21)的代码中，子类改写了父类的 synchronized 方法，然后调用父类中的方法，此时如果没有可重入的锁，那么这段代码将产生死锁。由于 Widget 和 LoggingWidget 中 doSomething 方法都是 synchronized 方法，因此每个 doSomething 方法在执行前都会获取 Widget 上的锁。然而，如果内置锁不是可重入的，那么在调用 super.doSomething 时将无法获得 Widget 上的锁，因为这个锁已经被持有，从而线程将永远停顿下去，等待一个永远也无法获得的锁。重入则避免了这种死锁情况的发生。

### 2.4 用锁来保护状态

> 一种常见的错误是认为，只有在写入共享变量时才需要使用同步，然而事实并非如此（3.1 节将进一步解释其中的原因）。

> 并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。

### 2.5 活跃性与性能

> 当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络 I/O 或控制台 I/O），一定不要持有锁。

## 第 3 章 - 对象的共享

> 同步还有另一个重要的方面：内存可见性（Memory Visibility）。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。

### 3.1 可见性

>在程序清单 3-1 (P27)中的 NoVisibility 说明了当多个线程在没有同步的情况下共享数据时出现的错误。
>在代码中，主线程和读线程都将访问共享变量 ready 和 number。主线程启动读线程，然后将 number 设为 42，并将 ready 设为 true。读线程一直循环直到发现 ready 的值变为 true，然后输出 number 的值。虽然 NoVisibility 看起来会输出 42，但事实上很可能输出 0，或者根本无法终止。这是因为在代码中没有使用足够的同步机制，因此无法保证主线程写入的 ready 值和 number 值对于读线程来说是可见的。

Java 内存模型(JMM) 中可以概括为三种对象：线程、线程的局部变量池、主内存。
线程从主内存读取数据后，会将其放到线程的局部变量池中(如寄存器等)，之后直接更改，更改后地数据可能不会再放到主内存中。因此两个线程之间存在同一个数据不同值的可能性。

#### 3.1.1 失效数据

>程序清单 3-2 中的 Mutablelnteger 不是线程安全的，因为 get 和 set 都是在没有同步的情况下访问 value 的。与其他问题相比，失效值问题更容易出现：如果某个线程调用了 set，那么另一个正在调用 get 的线程可能会看到更新后的 value 值，也可能看不到。

方法 1 需要对 get 和 set 方法加上 synchronized
方法 2 对 value 变量增加 volatile 修饰符

#### 3.1.2 非原子的 64 位操作

> 当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性。

> 最低安全性适用于绝大多数变量，但是存在一个例外：非 volatile 类型的 64 位数值变量（double 和 long，请参见 3.1.4 节）。
> 
> Java 内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非 volatile 类型的 long 和 double 变量，JVM 允许将 64 位的读操作或写操作分解为两个 32 位的操作。当读取一个非 volatile 类型的 long 变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高 32 位和另一个值的低 32 位。

#### 3.1.3 加锁与可见性

> 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

#### 3.1.4 Volatile 变量

> Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。

> 在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 sychronized 关键字更轻量级的同步机制。

> 然而，我们并不建议过度依赖 volatile 变量提供的可见性。如果在代码中依赖 volatile 变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难以理解。

> 仅当 volatile 变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用 volatile 变量。volatile 变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如，初始化或关闭）

> volatile 变量通常用做某个操作完成、发生中断或者状态的标志，

> volatile 的语义不足以确保递增操作（count++）的原子性，除非你能确保只有一个线程对变量执行写操作。

只能保证变量的可见性，不能保证变量修改时的原子性。

> 加锁机制既可以确保可见性又可以确保原子性，而 volatile 变量只能确保可见性。

> 当且仅当满足以下所有条件时，才应该使用 volatile 变量：
> 
> - 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
> - 该变量不会与其他状态变量一起纳入不变性条件中。
> - 在访问变量时不需要加锁。

> 在当前大多数处理器架构上，读取 volatile 变量的开销只比读取非 volatile 变量的开销略高一些。

> 调试小提示：对于服务器应用程序，无论在开发阶段还是在测试阶段，当启动 JVM 时一定都要指定-server 命令行选项。server 模式的 JVM 将比 client 模式的 JVM 进行更多的优化，例如将循环中未被修改的变量提升到循环外部，因此在开发环境（client 模式的 JVM）中能正确运行的代码，可能会在部署环境（server 模式的 JVM）中运行失败。

### 3.2 发布与逸出

> 如果在对象构造完成之前就发布该对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况就被称为逸出（Escape）

> 发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象，

> 当发布某个对象时，可能会间接地发布其他对象。如果将一个 Secret 对象添加到集合 knownSecrets 中，那么同样会发布这个对象，因为任何代码都可以遍历这个集合，并获得对这个新 Secret 对象的引用。同样，如果从非私有方法中返回一个引用，那么同样会发布返回的对象。

> 最后一种发布对象或其内部状态的机制就是发布一个内部的类实例，

> 当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。即使发布对象的语句位于构造函数的最后一行也是如此。如果 this 引用在构造过程中逸出，那么这种对象就被认为是不正确构造

> 不要在构造过程中使 this 引用逸出。

> 在构造过程中使 this 引用逸出的一个常见错误是，在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于 Thread 或 Runnable 是该对象的一个内部类），this 引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个 start 或 initialize 方法来启动（请参见第 7 章了解更多关于服务生命周期的内容）。在构造函数中调用一个可改写的实例方法时（既不是私有方法，也不是终结方法），同样会导致 this 引用在构造过程中逸出。

> 程序清单 3-8　使用工厂方法来防止 this 引用在构造过程中逸出

### 3.3 线程封闭

#### 3.3.1 Ad-hoc 线程封闭

> Ad-hoc 线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc 线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。

> 在 volatile 变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的 volatile 变量执行写入操作，那么就可以安全地在这些共享的 volatile 变量上执行“读取-修改-写入”的操作。在这种情况下，相当于将修改操作封闭在单个线程中以防止发生竞态条件，并且 volatile 变量的可见性保证还确保了其他线程能看到最新的值。

> 由于 Ad-hoc 线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术（例如，栈封闭或 ThreadLocal 类）。

#### 3.3.2 栈封闭

> 栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。

#### 3.3.3 ThreadLocal 类

> 维持线程封闭性的一种更规范方法是使用 ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 提供了 get 与 set 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此 get 总是返回由当前执行线程在调用 set 时设置的最新值。

> ThreadLocal 对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。

> 由于 JDBC 的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将 JDBC 的连接保存到 ThreadLocal 对象中，每个线程都会拥有属于自己的连接

> 当某个线程初次调用 ThreadLocal.get 方法时，就会调用 initialValue 来获取初始值。从概念上看，你可以将 ThreadLocal<T＞视为包含了 Map＜Thread, T＞对象，其中保存了特定于该线程的值，但 ThreadLocal 的实现并非如此。这些特定于线程的值保存在 Thread 对象中，当线程终止后，这些值会作为垃圾回收。

> 假设你需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为 ThreadLocal 对象（如果全局变量的语义允许），可以维持线程安全性。然而，如果将应用程序范围内的缓存转换为线程局部的缓存，就不会有太大作用。

### 3.4 不变性

> 不可变对象一定是线程安全的。

> 不可变性并不等于将对象中所有的域都声明为 final 类型，即使对象中所有的域都是 final 类型的，这个对象也仍然是可变的，因为在 final 类型的域中可以保存对可变对象的引用。

> 当满足以下条件时，对象才是不可变的：
> 
> - 对象创建以后其状态就不能修改。
> - 对象的所有域都是 final 类型。
> - 对象是正确创建的（在对象的创建期间，this 引用没有逸出）。

#### 3.4.1 Final 域

> 关键字 final 可以视为 C++中 const 机制的一种受限版本，用于构造不可变性对象。final 类型的域是不能修改的（但如果 final 域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。然而，在 Java 内存模型中，final 域还有着特殊的语义。final 域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。

> 正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为 final 域”也是一个良好的编程习惯。

#### 3.4.2 使用 Volatile 类型来发布不可变对象

> 每当需要对一组相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据，例如程序清单 3-12 (P40)中的 OneValueCache.

>程序清单 3-13 中的 VolatileCachedFactorizer 使用了 OneValueCache 来保存缓存的数值及其因数。当一个线程将 volatile 类型的 cache 设置为引用一个新的 OneValueCache 时，其他线程就会立即看到新缓存的数据。

> 因为 OneValueCache 是不可变的，并且在每条相应的代码路径中只会访问它一次。通过使用包含多个状态变量的容器对象来维持不变性条件，并使用一个 volatile 类型的引用来确保可见性，使得 Volatile CachedFactorizer 在没有显式地使用锁的情况下仍然是线程安全的。

秒啊！

>如果在 OneValueCache 和构造函数中没有调用 copyOf，那么 OneValueCache 就不是不可变的。

这里不懂.

### 3.5 安全发布

#### 3.5.1 不正确的发布：正确的对象被破坏

```java
public class Holder{
	private int n;
	public Holder(int n) { this.n=n; }
	public void assertSanity() {
		if(n!=n) 	throw new AssertionError("This statement is false.");
	}
}
```

> 由于没有使用同步来确保 Holder 对象对其他线程可见，因此将 Holder 称为“未被正确发布”。在未被正确发布的对象中存在两个问题。
> 
> 首先，除了发布对象的线程外，其他线程可以看到的 Holder 域是一个失效值，因此将看到一个空引用或者之前的旧值。
> 
> 然而，更糟糕的情况是，线程看到 Holder 引用的值是最新的，但 Holder 状态的值却是失效的。情况变得更加不可预测的是，某个线程在第一次读取域时得到失效值，而再次读取这个域时会得到一个更新值，这也是 assertSainty 抛出 AssertionError 的原因。

>问题并不在于 Holder 类本身，而是在于 Holder 类未被正确地发布。然而，如果将 n 声明为 final 类型，那么 Holder 将不可变，从而避免出现不正确发布的问题。

>尽管在构造函数中设置的域值似乎是第一次向这些域中写入的值，因此不会有“更旧的”值被视为失效值，但 Object 的构造函数会在子类构造函数运行之前先将默认值写入所有的域。因此，某个域的默认值可能被视为失效值。

JVM 创建对象的时候，先全部赋值为默认值，然后再使用构造函数初始化。
当设置为 final 时，则 JVM 创建对象时，不会先使用默认值赋值再赋予设置的值。

#### 3.5.3 安全发布的常用模式

> 要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。
> 
> 一个正确构造的对象可以通过以下方式来安全地发布：
> - 在静态初始化函数中初始化一个对象引用。
> - 将对象的引用保存到 volatile 类型的域或者 AtomicReferance 对象中。
> - 将对象的引用保存到某个正确构造对象的 final 类型域中。
> - 将对象的引用保存到一个由锁保护的域中。

> 有锁保护的域中：
> - 通过将一个键或者值放入 Hashtable、synchronizedMap 或者 ConcurrentMap 中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。
> - 通过将某个元素放入 Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList 或 synchronizedSet 中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。
> - 通过将某个元素放入 BlockingQueue 或者 ConcurrentLinkedQueue 中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。

> 要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器：
> public static Holder holder = new Holder(42);
> 静态初始化器由 JVM 在类的初始化阶段执行。由于在 JVM 内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布

#### 3.5.4 事实不可变对象

> 如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象（Effectively Immutable Object）”。

> 在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。

需要注意的是，事实不可变对象发布时需要进行安全发布。例如，将对象的引用保存到一个由锁保护的域中。否则，例如仅仅使用一个 HashMap<Integer, Object> 对象来存储数据，保证 value 不会被修改也是不可以的。因为 HashMap 本身不是线程安全的，可能 get 数据时正处于扩容阶段，导致数据获取不到。

是这样理解的吗？

#### 3.5.5 可变对象

> 对象的发布需求取决于它的可变性：
> 
> - 不可变对象可以通过任意机制来发布。
> - 事实不可变对象必须通过安全方式来发布。
> - 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

#### 3.5.6 安全地共享对象

> 许多并发错误都是由于没有理解共享对象的这些“既定规则”而导致的。当发布一个对象时，必须明确地说明对象的访问方式。

> 在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：
> 
> - 线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
> - 只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。
> - 线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。
> - 保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

## 第4章 - 对象的组合

###  4.1 设计线程安全的类

> 在设计线程安全类的过程中，需要包含以下三个基本要素：
>
> - 找出构成对象状态的所有变量。
> - 找出约束状态变量的不变性条件。
> - 建立对象状态的并发访问管理策略。

> 同步策略(Synchronization Policy)定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性、线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。要确保开发人员可以对这个类进行分析与维护，就必须将同步策略写为正式文档。

####  4.1.1 收集同步需求(不变性条件、后验条件)

> 要确保类的线程安全性，就需要确保它的不变性条件不会在并发访问的情况下被破坏，这就需要对其状态进行推断。

不变性条件：value一定不为负。

> 在操作中还会包含一些后验条件来判断状态迁移是否是有效的。如果Counter的当前状态为17，那么下一个有效状态只能是18。当下一个状态需要依赖当前状态时，这个操作就必须是一个复合操作。

后验条件：如果value为16，那么value下一次更改时必须变为17.

当下一个状态依赖于当前状态时，这个操作必须是复合操作，需加锁完成。

> 在类中也可以包含同时约束多个状态变量的不变性条件。
>
> 在一个表示数值范围的类(例如程序清单4-10中的NumberRange)中可以包含两个状态变量，分别表示范围的上界和下界。这些变量必须遵循的约束是，下界值应该小于或等于上界值。
>
> 类似于这种包含多个变量的不变性条件将带来原子性需求：这些相关的变量必须在单个原子操作中进行读取或更新。不能首先更新一个变量，然后释放锁并再次获得锁，然后再更新其他的变量。因为释放锁后，可能会使对象处于无效状态。如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。

多个状态变量的不变性条件：需要加锁完成。

> 如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。

了解了对象的不变性条件和后验条件，才可以着手去设计与实现线程安全性。在此基础上实现线程安全性，需要使用原子性和封装性。

#### 4.1.2 依赖状态的操作(先验条件)

> 类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件(Precondition)。例如，不能从空队列中移除一个元素，在删除元素前，队列必须处于“非空的”状态。如果在某个操作中包含有基于状态的先验条件，那么这个操作就称为依赖状态的操作。

先验条件：如队列不为空，才能poll元素。属于依赖状态的操作。

> 但在并发程序中，先验条件可能会由于其他线程执行的操作而变成真。在并发程序中要一直等到先验条件为真，然后再执行该操作。

AtomicInteger 自增操作的实现是CAS+自旋机制，是否属于先验条件呢？

> 要想实现某个等待先验条件为真时才执行的操作，一种更简单的方法是通过现有库中的类(例如阻塞队列[Blocking Queue]或信号量[Semaphore])来实现依赖状态的行为。第5章将介绍一些阻塞类，例如BlockingQueue、Semaphore以及其他的同步工具类。第14章将介绍如何使用在平台与类库中提供的各种底层机制来创建依赖状态的类。

####  4.1.3 状态的所有权

> 一个对象状态的概念：
> 如果以某个对象为根节点构造一张对象图，那么该对象的状态将是对象图中所有对象包含的域的一个子集。
>
> 如果分配并填充了一个HashMap对象，那么就相当于创建了多个对象：HashMap对象，在HashMap对象中包含的多个对象，以及在Map.Entry中可能包含的内部对象。



> 所有权与封装性总是相互关联的：
> 对象封装它拥有的状态，反之也成立，即对它封装的状态拥有所有权。



> 所有权意味着控制权。然而，如果发布了某个可变对象的引用，那么就不再拥有独占的控制权，最多是“共享控制权”。
>
> 对于从构造函数或者从方法中传递进来的对象，类通常并不拥有这些对象，除非这些方法是被专门设计为转移传递进来的对象的所有权(例如，同步容器封装器的工厂方法)。



> 容器类通常表现出一种“所有权分离”的形式，其中容器类拥有其自身的状态，而客户代码则拥有容器中各个对象的状态。
>
> Servlet框架中的ServletContext就是其中一个示例。ServletContext为Servlet提供了类似于Map形式的对象容器服务，在ServletContext中可以通过名称来注册(setAttribute)或获取(getAttribute)应用程序对象。由Servlet容器实现的ServletContext对象必须是线程安全的，因为它肯定会被多个线程同时访问。当调用setAttribute和getAttribute时，Servlet不需要使用同步，但当使用保存在ServletContext中的对象时，则可能需要使用同步。这些对象由应用程序拥有，Servlet容器只是替应用程序保管它们。



> 为了防止多个线程在并发访问同一个对象时产生的相互干扰，这些对象应该要么是线程安全的对象，要么是事实不可变的对象，或者由锁来保护的对象。

###  4.2 实例封闭

>如果某对象不是线程安全的，那么可以通过多种技术使其在多线程程序中安全地使用。

1 加锁

2 volatile 可见性

3 线程封闭

> 封装简化了线程安全类的实现过程，它提供了一种实例封闭机制(InstanceConfinement)，通常也简称为“封闭”。
>
> 将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。

例如：将Point对象作为ClassTmp类的私有成员，只能使用加锁的get或set来进行访问。

> 被封闭对象一定不能超出它们既定的作用域。封装的方式有：
>
> - 可以封闭在类的一个实例(例如作为类的一个私有成员)中，
> - 或者封闭在某个作用域内(例如作为一个局部变量)，
> - 或者封闭在线程内(例如在某个线程中将对象从一个方法传递到另一个方法，而不是在多个线程之间共享该对象)。
>
> 当然，对象本身不会逸出——出现逸出情况的原因通常是由于开发人员在发布对象时超出了对象既定的作用域。



> 在Java平台的类库中还有很多线程封闭的示例，其中有些类的唯一用途就是将非线程安全的类转化为线程安全的类。一些基本的容器类并非线程安全的，例如ArrayList和HashMap，但类库提供了包装器工厂方法(例如Collections.synchronizedList及其类似方法)，使得这些非线程安全的类可以在多线程环境中安全地使用。这些工厂方法通过“装饰器(Decorator)”模式(Gamma et al.，1995)将容器类封装在一个同步的包装器对象中，而包装器能将接口中的每个方法都实现为同步方法，并将调用请求转发到底层的容器对象上。



> 封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。

####  4.2.1 Java监视器模式

> 遵循Java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。Java监视器模式仅仅是一种编写代码的约定，对于任何一种锁对象，只要自始至终都使用该锁对象，都可以用来保护对象的状态。

两种实现：

1. 使用对象的内置锁(或任何其他可通过公有方式访问的锁)。例如，get和set方法加上Synchronized修饰。
2. 使用私有的锁对象，例如，对于封装的对象进行加锁，如下面所示。或者也可以生成一个私有的其他对象，获取该对象的锁才可以操作被封装的对象，有些类似于redis使用setnx实现分布式锁的原理。

> ```java
> public class PrivateLock{
>  private final Object myLock=new Object(); 
>  @GuardedBy("myLock")Widget widget; 
>  void someMethod(){
>      synchronized(myLock){
>      //访问或修改Widget的状态}
>      }
>  }
> }
> ```
>

> 使用私有的锁对象而不是对象的内置锁(或任何其他可通过公有方式访问的锁)，有许多优点。
>
> 私有的锁对象可以将锁封装起来，使客户代码无法得到锁，但客户代码可以通过公有方法来访问锁，以便(正确或者不正确地)参与到它的同步策略中。如果客户代码错误地获得了另一个对象的锁，那么可能会产生活跃性问题。此外，要想验证某个公有访问的锁在程序中是否被正确地使用，则需要检查整个程序，而不是单个的类。

####  4.2.2 示例：车辆追踪

> ```java
> @ThreadSafepublic 
> class MonitorVehicleTracker{
> @GuardedBy("this")
> private final Map<String, MutablePoint>locations; 
> public MonitorVehicleTracker(Map<String, MutablePoint>locations){
> this.locations=deepCopy(locations); 
> }
> public synchronized Map<String, MutablePoint>getLocations(){
> return deepCopy(locations); 
> }
> public synchronized MutablePoint getLocation(String id){
> MutablePoint loc=locations.get(id); 
> return loc==null?null：new MutablePoint(loc); 
> }
> public synchronized void setLocation(String id, int x, int y){
> MutablePoint loc=locations.get(id); 
> if(loc==null)
>    throw new IllegalArgumentException("No such ID："+id); loc.x=x; loc.y=y; 
> }
> private static Map<String, MutablePoint>deepCopy(Map<String, MutablePoint>m){
> Map<String, MutablePoint>result=new HashMap<String, MutablePoint>(); 
> for(String id：m.keySet())
>  	result.put(id, new MutablePoint(m.get(id))); 
> 	return Collections.unmodifiableMap(result); 
> }
> }
> 
> @NotThreadSafepublic 
> class MutablePoint{
> public int x, y; 
> public MutablePoint(){x=0; y=0; }
> public MutablePoint(MutablePoint p){this.x=p.x; this.y=p.y; }
> }
> ```
>

> 上述代码的缺点：
> 由于deepCopy是从一个synchronized方法中调用的，因此在执行时间较长的复制操作中，tracker的内置锁将一直被占有，当有大量车辆需要追踪时，会严重降低用户界面的响应灵敏度。

如果可以，尽可能让锁的粒度下沉，或者使用现有的线程安全对象。这里，可以使用具有线程安全的Map实现类，如ConcurrentHashMap等。如此，getLocation方法只需要直接使用ConcurrentHashMap的接口就可以，不需要再加锁，也不用深拷贝。

###  4.3 线程安全性的委托

> 大多数对象都是组合对象。当从头开始构建一个类，或者将多个非线程安全的类组合为一个类时，Java监视器模式是非常有用的。但是，如果类中的各个组件都已经是线程安全的，会是什么情况呢？我们是否需要再增加一个额外的线程安全层？答案是“视情况而定”。

之前提到的，检查再操作，putIfAbsent。

####  4.3.1 示例：基于委托的车辆追踪器

> ```java
> @Immutablepublic 
> class Point{
>  public final int x, y; 
>  public Point(int x, int y){
>      this.x=x; this.y=y; 
>  }
> }
> 
> @ThreadSafepublic 
> class DelegatingVehicleTracker{
>  private fnal ConcurrentMap＜String, Point＞locations；
>  private fnal Map＜String, Point＞unmodifiableMap；
>  public DelegatingVehicleTracker（Map＜String, Point＞points）{
>      locations=new ConcurrentHashMap＜String, Point＞（points）；
>      unmodifiableMap=Collections.unmodifableMap（locations）；
>  }
>  public Map＜String, Point＞getLocations（）{
>      return unmodifiableMap；
>  }
>  public Point getLocation（String id）{
>      return locations.get（id）；
>  }                                             
>  public void setLocation（String id, int x, int y）{
>      if（locations.replace（id, new  Point（x, y））==null）
>          throw new IllegalArgumentException（"invalid vehicle name："+id）；
>  }
> }
> ```

> Point类是不可变的，因而它是线程安全的。不可变的值可以被自由地共享与发布，因此在返回location时不需要复制。

> 如果使用最初的MutablePoint类而不是Point类，就会破坏封装性，因为getLocations会发布一个指向可变状态的引用，而这个引用不是线程安全的。需要注意的是，我们稍微改变了车辆追踪器类的行为。在使用监视器模式的车辆追踪器中返回的是车辆位置的快照，而在使用委托的车辆追踪器中返回的是一个不可修改但却实时的车辆位置视图。这意味着，如果线程A调用getLocations，而线程B在随后修改了某些点的位置，那么在返回给线程A的Map中将反映出这些变化。在前面提到过，这可能是一种优点(更新的数据)，也可能是一种缺点(可能导致不一致的车辆位置视图)，具体情况取决于你的需求。

> 如果需要一个不发生变化的车辆视图，那么getLocations可以返回对locations这个Map对象的一个浅拷贝(Shallow Copy)
>
> public Map<String, Point>getLocations(){
> 	return Collections.unmodifiableMap(new HashMap<String, Point>(locations)); 
> }

####  4.3.2 独立的状态变量

> 可以将线程安全性委托给多个状态变量，只要这些变量是彼此独立的，即组合而成的类并不会在其包含的多个状态变量上增加任何不变性条件。

> CopyOnWriteArrayList来保存各个监听器列表。它是一个线程安全的链表，特别适用于管理监听器列表(参见5.2.3节)

> 此外，由于各个状态之间不存在耦合关系，因此VisualComponent可以将它的线程安全性委托给mouseListeners和keyListeners等对象。
>
> ```java
> public class VisualComponent{
>  private final List＜KeyListener＞keyListeners=new CopyOnWriteArrayList＜KeyListener＞（）；
>  private final List＜MouseListener＞mouseListeners=new CopyOnWriteArrayList＜MouseListener＞（）；
>  public void addKeyListener（KeyListener listener）{keyListeners.add（listener）；}
> }
> ```

#### 4.3.3 当委托失效时(状态变量之间不独立)

> 由于状态变量lower和upper不是彼此独立的，因此NumberRange不能将线程安全性委托给它的线程安全状态变量。

> 如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。反之，不可以。

#### 4.3.4 发布底层的状态变量

> 当把线程安全性委托给某个对象的底层状态变量时，在什么条件下才可以发布这些变量从而使其他类能修改它们？答案仍然取决于在类中对这些变量施加了哪些不变性条件。
>
> 如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。

#### 4.3.5 示例：发布状态的车辆追踪器

>我们来构造车辆追踪器的另一个版本，并在这个版本中发布底层的可变状态。我们需要修改接口以适应这种变化，即使用可变且线程安全的Point类。

车辆追踪器将线程安全性委托给了locations变量，而locations变量属于ConcurrentHashMap，也是线程安全的。因此，若发布可变状态的Point，那么只需要保证Point是线程安全的就可以。

> ```java
> @ThreadSafe
> public class SafePoint{
>  @GuardedBy（"this"）private int x, y；
>  private SafePoint（int[]a）{this（a[0]，a[1]）；}
>  public SafePoint（SafePoint p）{this（p.get（））；}
>  public SafePoint（int x, int y）{this.x=x；this.y=y；}
>  public synchronized int[]get（）{return new int[]{x, y}；}
>  public synchronized void set（int x, int y）{this.x=x；this.y=y；}
> }
> ```

> 如果将拷贝构造函数实现为this(p.x, p.y)，那么会产生竞态条件，而私有构造函数则可以避免这种竞态条件。这是私有构造函数捕获模式(PrivateConstructor Capture Idiom, Bloch and Gafter，2005)的一个实例。

需要注意！！！这里自己很容易忽略。

###  4.4 在现有的线程安全类中添加功能

总结：

1. 修改原来的类
2. 扩展该类，如extend或implement
3. 客户端加锁机制，对被扩展的对象进行加锁
4. 组合/Java监视器模式，然后在扩展功能上对被监视的对象进行加锁。

> 要添加一个新的原子操作，最安全的方法是修改原始的类。
>
> 但这通常无法做到，因为你可能无法访问或修改类的源代码。要想修改原始的类，就需要理解代码中的同步策略，这样增加的功能才能与原有的设计保持一致。如果直接将新方法添加到类中，那么意味着实现同步策略的所有代码仍然处于一个源代码文件中，从而更容易理解与维护。

> 另一种方法是扩展这个类，假定在设计这个类时考虑了可扩展性。
>
> ```java
> public class BetterVector<E>extends Vector<E>{
>  public synchronized boolean putIfAbsent(E x){
>      ...
>  }
> }
> ```

> “扩展”方法比直接将代码添加到类中更加脆弱，因为现在的同步策略实现被分布到多个单独维护的源代码文件中。
> 如果底层的类改变了同步策略并选择了不同的锁来保护它的状态变量，那么子类会被破坏，因为在同步策略改变后它无法再使用正确的锁来控制对基类状态的并发访问。(在Vector的规范中定义了它的同步策略，因此BetterVector不存在这个问题。)

#### 4.4.1 客户端加锁机制

> 对于由Collections.synchronizedList封装的ArrayList，这两种方法在原始类中添加一个方法或者对类进行扩展都行不通，因为客户代码并不知道在同步封装器工厂方法中返回的List对象的类型。

> 第三种策略是扩展类的功能，但并不是扩展类本身，而是将扩展代码放入一个“辅助类”中。

> ```java
> @NotThreadSafepublic 
> class ListHelper<E>{
>  public List<E>list=Collections.synchronizedList(new ArrayList<E>()); 
>  public synchronized boolean putIfAbsent(E x){
>  	boolean absent=！list.contains(x); 
>      if(absent)list.add(x); return absent; 
>  }
> }
> ```

> 为什么这种方式不能实现线程安全性？毕竟，putIfAbsent已经声明为synchronized类型的变量，对不对？问题在于在错误的锁上进行了同步。无论List使用哪一个锁来保护它的状态，可以确定的是，这个锁并不是ListHelper上的锁。ListHelper只是带来了同步的假象，尽管所有的链表操作都被声明为synchronized，但却使用了不同的锁，这意味着putIfAbsent相对于List的其他操作来说并不是原子的，因此就无法确保当putIfAbsent执行时另一个线程不会修改链表。

线程不安全的原因在于加锁的对象不同。putIfAbsent 方法申请对ListHelper对象加锁。直接调用list方法时，申请对list对象或更小粒度对象加锁。两个锁不同，因此putIfAbsent 方法操作时，list对象可能被其他对象操作。

解决方法如下，直接对list对象进行加锁。

> ```java
> public boolean putIfAbsent(E x){
>  synchronized(list){
>      boolean absent=！list.contains(x); 
>      if(absent)list.add(x); return absent; 
>  }
> }
> ```

> 通过添加一个原子操作来扩展类是脆弱的，因为它将类的加锁代码分布到多个类中。然而，客户端加锁却更加脆弱，因为它将类C的加锁代码放到与C完全无关的其他类中。当在那些并不承诺遵循加锁策略的类上使用客户端加锁时，要特别小心。

> 客户端加锁机制与扩展类机制有许多共同点，二者都是将派生类的行为与基类的实现耦合在一起。正如扩展会破坏实现的封装性[EJ Item 14]，客户端加锁同样会破坏同步策略的封装性。

#### 4.4.2 组合

> 当为现有的类添加一个原子操作时，有一种更好的方法：组合(Composition)。程序清单4-16中的ImprovedList通过将List对象的操作委托给底层的List实例来实现List的操作，同时还添加了一个原子的putIfAbsent方法。(与Collections.synchronizedList和其他容器封装器一样，ImprovedList假设把某个链表对象传给构造函数以后，客户代码不会再直接使用这个对象，而只能通过ImprovedList来访问它。)

> ```java
> public class ImprovedList<T>implements List<T>{
>  private final List<T>list; 
>  public ImprovedList(List<T>list){this.list=list; }
>  ...
> }
> ```

> 事实上，我们使用了Java监视器模式来封装现有的List，并且只要在类中拥有指向底层List的唯一外部引用，就能确保线程安全性。

### 4.5 将同步策略文档化

> 用户可以通过查阅文档来判断某个类是否是线程安全的，而维护人员也可以通过查阅文档来理解其中的实现策略，避免在维护过程中破坏安全性。

> 在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。

> synchronized、volatile或者任何一个线程安全类都对应于某种同步策略，用于在并发访问时确保数据的完整性。

> 设计阶段是编写设计决策文档的最佳时间。

> 在设计同步策略时需要考虑多个方面，例如，将哪些变量声明为volatile类型，哪些变量用锁来保护，哪些锁保护哪些变量，哪些变量必须是不可变的或者被封闭在线程中的，哪些操作必须是原子操作等。其中某些方面是严格的实现细节，应该将它们文档化以便于日后的维护。还有一些方面会影响类中加锁行为的外在表现，也应该将其作为规范的一部分写入文档。

> 最起码，应该保证将类中的线程安全性文档化。它是否是线程安全的？在执行回调时是否持有一个锁？是否有某些特定的锁会影响其行为？不要让客户冒着风险去猜测。如果你不想支持客户端加锁也是可以的，但一定要明确地指出来。如果你希望客户代码能够在类中添加新的原子操作，如4.4节所示，那么就需要在文档中说明需要获得哪些锁才能实现安全的原子操作。如果使用锁来保护状态，那么也要将其写入文档以便日后维护，这很简单，只需使用标注@GuardedBy即可。如果要使用更复杂的方法来维护线程安全性，那么一定要将它们写入文档，因为维护者通常很难发现它们。

> 我们是否应该因为某个对象看上去是线程安全的而就假设它是安全的？是否可以假设通过获取对象的锁来确保对象访问的线程安全性？(只有当我们能控制所有访问该对象的代码时，才能使用这种带风险的技术，否则，这只能带来线程安全性的假象。)

> 如果某个类没有明确地声明是线程安全的，那么就不要假设它是线程安全的，从而有效地避免类似于SimpleDateFormat的问题。而另一方面，如果不对容器提供对象(例如HttpSession)的线程安全性做某种有问题的假设，也就不可能开发出一个基于Servlet的应用程序。

> 一个提高猜测准确性的方法是，从实现者(例如容器或数据库的供应商)的角度去解释规范，而不是从使用者的角度去解释。Servlet通常是在容器管理的(Container-Managed)线程中调用的，因此可以安全地假设：如果有多个这种线程在运行，那么容器是知道这种情况的。Servlet容器能生成一些为多个Servlet提供服务的对象，例如HttpSession或ServletContext。因此，Servlet容器应该预见到这些对象将被并发访问，因为它创建了多个线程，并且从这些线程中调用像Servlet.service这样的方法，而这个方法很可能会访问ServletContext。

如果文档没有注明，那么从实现者的角度猜测他是否对xxx对象提供线程安全。
