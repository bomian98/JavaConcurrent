---
number headings: 1
---

Java 并发编程实战
盖茨等
84 个想法

◆ 第一部分基础知识

## 第 2 章 - 线程安全性

> 要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的（Shared）和可变的（Mutable）状态的访问。

> “共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。

>线程安全性的实现：
>
>不在线程之间共享该状态变量。(ThreadLocal 或方法的局部变量)
>
>将状态变量修改为不可变的变量。
>
>在访问状态变量时使用同步。

>编写并发应用程序时，一种正确的编程方法就是：首先使代码正确运行，然后再提高代码的速度。
>即便如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能带来性能提升时，才进行优化。

确实，之前在做选排课系统时，我了解操作 Redis 是直接操作内存，相较于操作 MySQL 会更快一些。但是，我并没有实际的去测试使用 Redis 前后性能提升有多少。

>线程安全的程序是否完全由线程安全类构成？答案是否定的，完全由线程安全类构成的程序并不一定就是线程安全的，而在线程安全类中也可以包含非线程安全的类。

例如：判断在 ConcurrentHashMap 中是否存在某个 key，不存在，则插入数据。这就是不安全的指令，属于竞态条件的一种。

### 2.1 什么是线程安全性

> 当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

> 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

> 无状态对象一定是线程安全的。

> 大多数 Servlet 都是无状态的，从而极大地降低了在实现 Servlet 线程安全性时的复杂性。只有当 Servlet 在处理请求时需要保存一些信息，线程安全性才会成为一个问题。

### 2.2 原子性

>虽然递增操作++count 是一种紧凑的语法，使其看上去只是一个操作，但这个操作并非原子的，因而它并不会作为一个不可分割的操作来执行。实际上，它包含了三个独立的操作：读取 count 的值，将值加 1，然后将计算结果写入 count。这是一个“读取-修改-写入”的操作序列，并且其结果状态依赖于之前的状态。

自增操作不是一个原子操作！！

> 在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件（Race Condition）。

#### 2.2.1 竞态条件

> 最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作。

#### 2.2.2 延迟初始化中的竞态条件

>使用“先检查后执行”的一种常见情况就是延迟初始化。延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。

懒加载的单例模式，线程不安全。
可能存在两个线程都判空，并都创建了对象、赋值和返回，从而导致使用了地址不同的对象。

#### 2.2.3 复合操作

> 在 java.util.concurrent.atomic 包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。

AtomicInteger 的自增操作调用了下面的函数。
``` Java
@HotSpotIntrinsicCandidate
public final int getAndSetInt(Object o, long offset, int newValue) {
	int v;
	do {
		v = getIntVolatile(o, offset);
	} while (!weakCompareAndSetInt(o, offset, v, newValue));
	return v;
}
```

### 2.3 加锁机制

> 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

Redis 同理，如果某个操作需要更新两个数据，那么调用两次 Redis 的 API 是不行的。我当前使用的是借助 Lua 来操作

#### 2.3.1 内置锁

>Java 提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。（第 3 章将介绍加锁机制以及其他同步机制的另一个重要方面：可见性）
>
>同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。
>
>以关键字 synchronized 来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的 synchronized 方法以 Class 对象作为锁。

锁住方法：
1 - 普通方法，锁住的是当前执行该方法的实例对象
2 - 静态方法，锁住的是类对象。

#### 2.3.2 重入

> 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”

> 重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。
> 当计数值为 0 时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM 将记下锁的持有者，并且将获取计数值置为 1。
> 如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为 0 时，这个锁将被释放。

> 重入进一步提升了加锁行为的封装性，因此简化了面向对象并发代码的开发。在程序清单 2-7 (P21)的代码中，子类改写了父类的 synchronized 方法，然后调用父类中的方法，此时如果没有可重入的锁，那么这段代码将产生死锁。由于 Widget 和 LoggingWidget 中 doSomething 方法都是 synchronized 方法，因此每个 doSomething 方法在执行前都会获取 Widget 上的锁。然而，如果内置锁不是可重入的，那么在调用 super.doSomething 时将无法获得 Widget 上的锁，因为这个锁已经被持有，从而线程将永远停顿下去，等待一个永远也无法获得的锁。重入则避免了这种死锁情况的发生。

### 2.4 用锁来保护状态

> 一种常见的错误是认为，只有在写入共享变量时才需要使用同步，然而事实并非如此（3.1 节将进一步解释其中的原因）。

> 并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。

### 2.5 活跃性与性能

> 当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络 I/O 或控制台 I/O），一定不要持有锁。

## 第 3 章 - 对象的共享

> 同步还有另一个重要的方面：内存可见性（Memory Visibility）。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。

### 3.1 可见性

>在程序清单 3-1 (P27)中的 NoVisibility 说明了当多个线程在没有同步的情况下共享数据时出现的错误。
>在代码中，主线程和读线程都将访问共享变量 ready 和 number。主线程启动读线程，然后将 number 设为 42，并将 ready 设为 true。读线程一直循环直到发现 ready 的值变为 true，然后输出 number 的值。虽然 NoVisibility 看起来会输出 42，但事实上很可能输出 0，或者根本无法终止。这是因为在代码中没有使用足够的同步机制，因此无法保证主线程写入的 ready 值和 number 值对于读线程来说是可见的。

Java 内存模型(JMM) 中可以概括为三种对象：线程、线程的局部变量池、主内存。
线程从主内存读取数据后，会将其放到线程的局部变量池中(如寄存器等)，之后直接更改，更改后地数据可能不会再放到主内存中。因此两个线程之间存在同一个数据不同值的可能性。

#### 3.1.1 失效数据

>程序清单 3-2 中的 Mutablelnteger 不是线程安全的，因为 get 和 set 都是在没有同步的情况下访问 value 的。与其他问题相比，失效值问题更容易出现：如果某个线程调用了 set，那么另一个正在调用 get 的线程可能会看到更新后的 value 值，也可能看不到。

方法 1 需要对 get 和 set 方法加上 synchronized
方法 2 对 value 变量增加 volatile 修饰符

#### 3.1.2 非原子的 64 位操作

> 当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性。

> 最低安全性适用于绝大多数变量，但是存在一个例外：非 volatile 类型的 64 位数值变量（double 和 long，请参见 3.1.4 节）。
> 
> Java 内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非 volatile 类型的 long 和 double 变量，JVM 允许将 64 位的读操作或写操作分解为两个 32 位的操作。当读取一个非 volatile 类型的 long 变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高 32 位和另一个值的低 32 位。

#### 3.1.3 加锁与可见性

> 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

#### 3.1.4 Volatile 变量

> Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。

> 在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 sychronized 关键字更轻量级的同步机制。

> 然而，我们并不建议过度依赖 volatile 变量提供的可见性。如果在代码中依赖 volatile 变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难以理解。

> 仅当 volatile 变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用 volatile 变量。volatile 变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如，初始化或关闭）

> volatile 变量通常用做某个操作完成、发生中断或者状态的标志，

> volatile 的语义不足以确保递增操作（count++）的原子性，除非你能确保只有一个线程对变量执行写操作。

只能保证变量的可见性，不能保证变量修改时的原子性。

> 加锁机制既可以确保可见性又可以确保原子性，而 volatile 变量只能确保可见性。

> 当且仅当满足以下所有条件时，才应该使用 volatile 变量：
> 
> - 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
> - 该变量不会与其他状态变量一起纳入不变性条件中。
> - 在访问变量时不需要加锁。

> 在当前大多数处理器架构上，读取 volatile 变量的开销只比读取非 volatile 变量的开销略高一些。

> 调试小提示：对于服务器应用程序，无论在开发阶段还是在测试阶段，当启动 JVM 时一定都要指定-server 命令行选项。server 模式的 JVM 将比 client 模式的 JVM 进行更多的优化，例如将循环中未被修改的变量提升到循环外部，因此在开发环境（client 模式的 JVM）中能正确运行的代码，可能会在部署环境（server 模式的 JVM）中运行失败。

### 3.2 发布与逸出

> 如果在对象构造完成之前就发布该对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况就被称为逸出（Escape）

> 发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象，

> 当发布某个对象时，可能会间接地发布其他对象。如果将一个 Secret 对象添加到集合 knownSecrets 中，那么同样会发布这个对象，因为任何代码都可以遍历这个集合，并获得对这个新 Secret 对象的引用。同样，如果从非私有方法中返回一个引用，那么同样会发布返回的对象。

> 最后一种发布对象或其内部状态的机制就是发布一个内部的类实例，

> 当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。即使发布对象的语句位于构造函数的最后一行也是如此。如果 this 引用在构造过程中逸出，那么这种对象就被认为是不正确构造

> 不要在构造过程中使 this 引用逸出。

> 在构造过程中使 this 引用逸出的一个常见错误是，在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于 Thread 或 Runnable 是该对象的一个内部类），this 引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个 start 或 initialize 方法来启动（请参见第 7 章了解更多关于服务生命周期的内容）。在构造函数中调用一个可改写的实例方法时（既不是私有方法，也不是终结方法），同样会导致 this 引用在构造过程中逸出。

> 程序清单 3-8　使用工厂方法来防止 this 引用在构造过程中逸出

### 3.3 线程封闭

#### 3.3.1 Ad-hoc 线程封闭

> Ad-hoc 线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc 线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。

> 在 volatile 变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的 volatile 变量执行写入操作，那么就可以安全地在这些共享的 volatile 变量上执行“读取-修改-写入”的操作。在这种情况下，相当于将修改操作封闭在单个线程中以防止发生竞态条件，并且 volatile 变量的可见性保证还确保了其他线程能看到最新的值。

> 由于 Ad-hoc 线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术（例如，栈封闭或 ThreadLocal 类）。

#### 3.3.2 栈封闭

> 栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。

#### 3.3.3 ThreadLocal 类

> 维持线程封闭性的一种更规范方法是使用 ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 提供了 get 与 set 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此 get 总是返回由当前执行线程在调用 set 时设置的最新值。

> ThreadLocal 对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。

> 由于 JDBC 的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将 JDBC 的连接保存到 ThreadLocal 对象中，每个线程都会拥有属于自己的连接

> 当某个线程初次调用 ThreadLocal.get 方法时，就会调用 initialValue 来获取初始值。从概念上看，你可以将 ThreadLocal<T＞视为包含了 Map＜Thread, T＞对象，其中保存了特定于该线程的值，但 ThreadLocal 的实现并非如此。这些特定于线程的值保存在 Thread 对象中，当线程终止后，这些值会作为垃圾回收。

> 假设你需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为 ThreadLocal 对象（如果全局变量的语义允许），可以维持线程安全性。然而，如果将应用程序范围内的缓存转换为线程局部的缓存，就不会有太大作用。

### 3.4 不变性

> 不可变对象一定是线程安全的。

> 不可变性并不等于将对象中所有的域都声明为 final 类型，即使对象中所有的域都是 final 类型的，这个对象也仍然是可变的，因为在 final 类型的域中可以保存对可变对象的引用。

> 当满足以下条件时，对象才是不可变的：
> 
> - 对象创建以后其状态就不能修改。
> - 对象的所有域都是 final 类型。
> - 对象是正确创建的（在对象的创建期间，this 引用没有逸出）。

#### 3.4.1 Final 域

> 关键字 final 可以视为 C++中 const 机制的一种受限版本，用于构造不可变性对象。final 类型的域是不能修改的（但如果 final 域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。然而，在 Java 内存模型中，final 域还有着特殊的语义。final 域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。

> 正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为 final 域”也是一个良好的编程习惯。

#### 3.4.2 使用 Volatile 类型来发布不可变对象

> 每当需要对一组相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据，例如程序清单 3-12 (P40)中的 OneValueCache.

>程序清单 3-13 中的 VolatileCachedFactorizer 使用了 OneValueCache 来保存缓存的数值及其因数。当一个线程将 volatile 类型的 cache 设置为引用一个新的 OneValueCache 时，其他线程就会立即看到新缓存的数据。

> 因为 OneValueCache 是不可变的，并且在每条相应的代码路径中只会访问它一次。通过使用包含多个状态变量的容器对象来维持不变性条件，并使用一个 volatile 类型的引用来确保可见性，使得 Volatile CachedFactorizer 在没有显式地使用锁的情况下仍然是线程安全的。

秒啊！

>如果在 OneValueCache 和构造函数中没有调用 copyOf，那么 OneValueCache 就不是不可变的。

这里不懂.

### 3.5 安全发布

#### 3.5.1 不正确的发布：正确的对象被破坏

```java
public class Holder{
	private int n;
	public Holder(int n) { this.n=n; }
	public void assertSanity() {
		if(n!=n) 	throw new AssertionError("This statement is false.");
	}
}
```

> 由于没有使用同步来确保 Holder 对象对其他线程可见，因此将 Holder 称为“未被正确发布”。在未被正确发布的对象中存在两个问题。
> 
> 首先，除了发布对象的线程外，其他线程可以看到的 Holder 域是一个失效值，因此将看到一个空引用或者之前的旧值。
> 
> 然而，更糟糕的情况是，线程看到 Holder 引用的值是最新的，但 Holder 状态的值却是失效的。情况变得更加不可预测的是，某个线程在第一次读取域时得到失效值，而再次读取这个域时会得到一个更新值，这也是 assertSainty 抛出 AssertionError 的原因。

>问题并不在于 Holder 类本身，而是在于 Holder 类未被正确地发布。然而，如果将 n 声明为 final 类型，那么 Holder 将不可变，从而避免出现不正确发布的问题。

>尽管在构造函数中设置的域值似乎是第一次向这些域中写入的值，因此不会有“更旧的”值被视为失效值，但 Object 的构造函数会在子类构造函数运行之前先将默认值写入所有的域。因此，某个域的默认值可能被视为失效值。

JVM 创建对象的时候，先全部赋值为默认值，然后再使用构造函数初始化。
当设置为 final 时，则 JVM 创建对象时，不会先使用默认值赋值再赋予设置的值。

#### 3.5.3 安全发布的常用模式

> 要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。
> 
> 一个正确构造的对象可以通过以下方式来安全地发布：
> - 在静态初始化函数中初始化一个对象引用。
> - 将对象的引用保存到 volatile 类型的域或者 AtomicReferance 对象中。
> - 将对象的引用保存到某个正确构造对象的 final 类型域中。
> - 将对象的引用保存到一个由锁保护的域中。

> 有锁保护的域中：
> - 通过将一个键或者值放入 Hashtable、synchronizedMap 或者 ConcurrentMap 中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。
> - 通过将某个元素放入 Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList 或 synchronizedSet 中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。
> - 通过将某个元素放入 BlockingQueue 或者 ConcurrentLinkedQueue 中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。

> 要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器：
> public static Holder holder = new Holder(42);
> 静态初始化器由 JVM 在类的初始化阶段执行。由于在 JVM 内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布

#### 3.5.4 事实不可变对象

> 如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象（Effectively Immutable Object）”。

> 在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。

需要注意的是，事实不可变对象发布时需要进行安全发布。例如，将对象的引用保存到一个由锁保护的域中。否则，例如仅仅使用一个 HashMap<Integer, Object> 对象来存储数据，保证 value 不会被修改也是不可以的。因为 HashMap 本身不是线程安全的，可能 get 数据时正处于扩容阶段，导致数据获取不到。

是这样理解的吗？

#### 3.5.5 可变对象

> 对象的发布需求取决于它的可变性：
> 
> - 不可变对象可以通过任意机制来发布。
> - 事实不可变对象必须通过安全方式来发布。
> - 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

#### 3.5.6 安全地共享对象

> 许多并发错误都是由于没有理解共享对象的这些“既定规则”而导致的。当发布一个对象时，必须明确地说明对象的访问方式。

> 在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：
> 
> - 线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
> - 只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。
> - 线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。
> - 保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

